/* Generated by Together */

package mojo.ui.common;

import java.util.Map;
import mojo.km.messaging.IEvent;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.table.TableCellRenderer;
import javax.swing.table.DefaultTableCellRenderer;
import java.awt.Rectangle;
import java.awt.Color;
import javax.swing.border.Border;
import javax.swing.border.EmptyBorder;
import java.awt.Component;
import javax.swing.UIManager;
import javax.swing.JComponent;
import mojo.km.messaging.EventFactory;
import mojo.km.utilities.Reflection;
import mojo.km.dispatch.EventManager;
import java.util.Iterator;
import java.lang.reflect.Method;
import java.util.Hashtable;
import javax.swing.JLabel;

/**
 * Responsible for editing bean spec object propertyies.  Provides a Swing user interface based upon a JTable.
 *	@author Eric A Amundson
 * @modelguid {B59D0956-E665-4557-A5AE-A6B7333A3815}
 */
public class PropertyEditor extends javax.swing.JPanel implements EventCacheable {
    /**
     * Construct a property editor for event related to the inbound service name.
     * @param topic - specialized listener topic.
     * @param inboundServiceName - service name related to inbound event.
     * @param outboundEvent - the outbound event that will be modified upon properties changing.
     * @modelguid {6ADB7669-3D49-4E93-8331-9BAB81F24D65}
     */
    public PropertyEditor( String topic, String inboundServiceName, IEvent outboundEvent )
    {
		this.topic = topic;
        this.inboundServiceName = inboundServiceName;
        inboundEvent = EventFactory.getInstance( inboundServiceName );
        this.outboundEvent = outboundEvent;
		CellRenderer renderer = new CellRenderer();
        initGUI();
        Iterator i = Reflection.getAccessorMethods(inboundEvent.getClass());
        while (i.hasNext()) {
            Method method = (Method) i.next();
            String propName = Reflection.getPropertyName( method );
            propName = propName.substring(0,1).toLowerCase() + propName.substring(1);
            int count = tModel.getRowCount();
            tModel.setRowCount( count + 1);
            componentHash.put( ""+count+",0", new JLabel());
            componentHash.put( ""+count+",1", getInstance( method.getReturnType(), propName));
            tModel.setValueAt( propName, count, 0);

        }
         propertyTable.setDefaultRenderer( propertyTable.getColumn( "Name" ).getClass(), renderer );
         propertyTable.setDefaultRenderer( propertyTable.getColumn( "Value" ).getClass(), renderer);
    }

	/** @modelguid {F54AAE86-BC12-45DA-B55C-29398C74DF66} */
    private JComponent getInstance( Class propType, String propName )
    {
        return new IntegratedTextField(topic, inboundServiceName, outboundEvent, propName);
    }

	/** @modelguid {54BD6523-8538-47E2-B543-A1505E51F4F0} */
    public void setCache(Map cache) {
        this.cache = cache;
        Iterator vals = componentHash.values().iterator();
        while (vals.hasNext()) {
            JComponent aComp = (JComponent) vals.next();
            if (aComp instanceof EventCacheable) {
                ((EventCacheable) aComp).setCache( cache );
            }
        }

    }

	/** @modelguid {5378FD1B-711B-4A64-ACEF-DAAB3A7D044A} */
    public void postEvent(IEvent event) {
        if (cache == null){
            EventManager.getSharedInstance(EventManager.REQUEST).postEvent( event );
        } else {
            cache.put(event, event);
        }
    }

	/** @modelguid {A0D417EA-6154-4667-934B-86E9673CE5BA} */
    public void initGUI() {
        propertyTable = new JTable();
        tModel = new javax.swing.table.DefaultTableModel();
        tModel.addColumn("Name");
        tModel.addColumn("Value");
        propertyTable.setModel(tModel);
        jScrollPane1 = new JScrollPane();
        setLayout(new java.awt.BorderLayout());
        add(jScrollPane1, java.awt.BorderLayout.CENTER);
        jScrollPane1.getViewport().add(propertyTable);
        propertyTable.setBounds(new Rectangle(192, 119, 32, 32));
        jScrollPane1.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.LOWERED));
    }

	/** @modelguid {A2AE90FD-1995-4D7A-A1C0-A60FAB0FDAA4} */
    class TableModel extends javax.swing.table.DefaultTableModel {
		/** @modelguid {273B8C75-993D-474D-BC7D-7327206AAF3B} */
        public boolean isCellEditable(int row, int col) {
            //Note that the data/cell address is constant,
            //no matter where the cell appears onscreen.
            if (col < 1) {
                return false;
            } else {
                return true;
            }
        }
    }

	/** @modelguid {72B2BDF7-18F4-4107-B1B7-F364031B0BF3} */
    private JComponent getComponent( int row, int column )
    {
		return (JComponent) componentHash.get( row +"," +column );
    }

	/** @modelguid {A8361249-672C-41FE-9A7D-BAB351CF127B} */
    class CellRenderer implements TableCellRenderer {
		/** @modelguid {21BCC768-B0BA-47C2-B9B6-BADA5F41843C} */
        protected Border noFocusBorder = new EmptyBorder(1, 1, 1, 1);
        // We need a place to store the color the JLabel should be returned
        // to after its foreground and background colors have been set
        // to the selection background color.
        // These ivars will be made protected when their names are finalized.
		/** @modelguid {11D53242-74DA-4091-AED6-7BEB3CE523BD} */
        private Color unselectedForeground;
		/** @modelguid {0CA4969D-3C97-4F4F-906A-C939876673D1} */
        private Color unselectedBackground;

        /** Creates a default table cell renderer. 
         * @modelguid {3ABE189C-5AE4-4C2A-BB3F-B324E05496F0}
         */
        public CellRenderer() {
            setOpaque(true);
            setBorder(noFocusBorder);
        }

        /**
         * Overrides <code>JComponent.setForeground</code> to assign the unselected-foreground color to the specified color.
         * @param c set the foreground color to this value
         * @modelguid {3EDA304F-40D4-4563-8407-F6F4CD0F2655}
         */
        public void setForeground(Color c) {
            comp.setForeground(c);
            unselectedForeground = c;
        }

        /**
         * Overrides <code>JComponent.setForeground</code> to assign the unselected-background color to the specified color.
         * @param c set the background color to this value
         * @modelguid {EE5C16E4-1019-4F20-A75B-30775B786598}
         */
        public void setBackground(Color c) {
            comp.setBackground(c);
            unselectedBackground = c;
        }

        /**
         * Notification from the <code>UIManager</code> that the look and feel [L&F] has changed.
         * Replaces the current UI object with the latest version from the <code>UIManager</code>.
         * @see JComponent#updateUI
         * @modelguid {11C20A80-E513-409E-82A4-DEB1175CA6EA}
         */
        public void updateUI() {
            comp.updateUI();
            setForeground(null);
            setBackground(null);
        }
        // implements javax.swing.table.TableCellRenderer

        /**
         * Returns the default table cell renderer.
         * @param table  the <code>JTable</code>
         * @param value  the value to assign to the cell at <code>[row, column]</code>
         * @param isSelected true if cell is selected
         * @param isFocus true if cell has focus
         * @param row  the row of the cell to render
         * @param column the column of the cell to render
         * @return the default table cell renderer
         * @modelguid {27612555-FBE1-4E40-AC6D-F46DDDB92DBD}
         */
        public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected,
            boolean hasFocus, int row, int column) {
            	comp = getComponent( row, column );
                if (isSelected) {
                    comp.setForeground(table.getSelectionForeground());
                    comp.setBackground(table.getSelectionBackground());
                }
                else {
                    comp.setForeground((unselectedForeground != null) ? unselectedForeground : table.getForeground());
                    comp.setBackground((unselectedBackground != null) ? unselectedBackground : table.getBackground());
                }
                setFont(table.getFont());
                if (hasFocus) {
                    setBorder(UIManager.getBorder("Table.focusCellHighlightBorder"));
                    if (table.isCellEditable(row, column)) {
                        comp.setForeground(UIManager.getColor("Table.focusCellForeground"));
                        comp.setBackground(UIManager.getColor("Table.focusCellBackground"));
                    }
                } else {
                    setBorder(noFocusBorder);
                }
                setValue(value);
                // ---- begin optimization to avoid painting background ----
                Color back = getBackground();
                boolean colorMatch = (back != null) && (back.equals(table.getBackground())) && table.isOpaque();
                setOpaque(!colorMatch);
                // ---- end optimization to aviod painting background ----
                return comp;
        }

    /*
     * The following methods are overridden as a performance measure to
     * to prune code-paths are often called in the case of renders
     * but which we know are unnecessary.  Great care should be taken
     * when writing your own renderer to weigh the benefits and
     * drawbacks of overriding methods like these.
     */

        /** Overridden for performance reasons. See the <a href="#override">Implementation Note</a> for more information. 
         * @modelguid {FECCFE3D-5285-46C0-8266-223CD3AECBD5}
         */
        public void validate() { }

        /** Overridden for performance reasons. See the <a href="#override">Implementation Note</a> for more information. 
         * @modelguid {7C8E0D0E-9472-4043-8B77-9EE64455C6AD}
         */
        public void revalidate() { }

        /** Overridden for performance reasons. See the <a href="#override">Implementation Note</a> for more information. 
         * @modelguid {403308FB-67CD-4EE5-9731-1B739B673DF0}
         */
        public void repaint(long tm, int x, int y, int width, int height) { }

        /** Overridden for performance reasons. See the <a href="#override">Implementation Note</a> for more information. 
         * @modelguid {74B986A3-37C5-4F76-B7E1-D3AA7D05669B}
         */
        public void repaint(Rectangle r) { }

        /** Overridden for performance reasons. See the <a href="#override">Implementation Note</a> for more information. 
         * @modelguid {E5848779-67EF-4C67-9D81-61BC62DB2DE7}
         */
        protected void firePropertyChange(String propertyName, Object oldValue, Object newValue) {
            // Strings get interned...
            if (propertyName == "text") {
                //comp.firePropertyChange(propertyName, oldValue, newValue);
            }
        }


        /**
         * Sets the string for the cell being rendered to <code>value</code>.
         * @param value  the string value for this cell; if value is
         * <code>null</code> it sets the text value to an empty string
         * @see JLabel#setText
         * @modelguid {216D1820-9548-4C3E-8C15-A54C3C5DCBF8}
         */
        protected void setValue(Object value) {
            if (comp instanceof PropertyComponent) {
               ((PropertyComponent) comp).setValue((value == null) ? "" : value.toString());
            }
        }


		/** @modelguid {4BD2FF30-8AF5-495E-859B-3417F406832E} */
        private JComponent comp = null;

        /**
         * A subclass of <code>DefaultTableCellRenderer</code> that implements <code>UIResource</code>.
         * <code>DefaultTableCellRenderer</code> doesn't implement <code>UIResource</code>
         * directly so that applications can safely override the <code>cellRenderer</code> property with
         * <code>DefaultTableCellRenderer</code> subclasses. <p> <strong>Warning:</strong>
         * Serialized objects of this class will not be compatible with
         * future Swing releases.  The current serialization support is appropriate
         * for short term storage or RMI between applications running the same
         * version of Swing.  A future release of Swing will provide support for long term persistence.
         */
/*
        public static class UIResource extends DefaultTableCellRenderer implements javax.swing.plaf.UIResource {
        }
*/
    }


	/** @modelguid {7943BE17-BD7C-4D09-AFB8-C7657F0F7C93} */
    private JScrollPane jScrollPane1;
	/** @modelguid {11F713B2-B904-4618-9CCF-10846389618C} */
    private JTable propertyTable;
	/** @modelguid {0A169059-6DFB-4856-965D-741426DBD902} */
    private javax.swing.table.DefaultTableModel tModel;
	/** @modelguid {85F806D4-7129-4F24-8B1D-2957B4BE2B92} */
    private IEvent inboundEvent = null;
	/** @modelguid {7141D337-AFF2-4D4E-B4E7-E9AE89EEDE75} */
    private String inboundServiceName = null;
	/** @modelguid {81FC6199-593B-4813-B5B8-7F390D44A560} */
    private IEvent outboundEvent = null;
	/** @modelguid {D15AA195-33B1-48A9-8775-D984FB98D174} */
    private String topic = null;
	/** @modelguid {B1DAAE42-B767-4949-B877-729546D44196} */
    private Hashtable componentHash = new Hashtable();
	/** @modelguid {E1C930A2-B6A2-4E0A-ACC9-B2C9CAAF1F86} */
    private Map cache = null;

}
