/* Generated by Together */

package mojo.km.properties;

import java.lang.reflect.*;
import java.util.Iterator;
import java.util.Enumeration;
import java.util.*;
import java.sql.Timestamp;
import java.sql.Date;
//import javax.servlet.http.HttpServletRequest;

import mojo.km.config.PropertyBundleProperties;
import mojo.km.messaging.IEvent;
// import mojo.km.security.SecurityManager;
import mojo.km.utilities.Reflection;

/**
 * Responsible for managing properties that are shared by multiple application components.  It prescribes an event model for
 * validating the contract for getting and setting various named application properties.
 * @modelguid {B28D73AD-0545-495B-AA30-75C6067AF5E8}
 */
public class PropertyManager {
	/** @modelguid {B68D1869-0013-4BA6-A83A-50A09259C8CE} */
    private static char BLIND = '*';

    /** PropertyCopier constructor comment. 
     * @modelguid {5F1EF9D4-F21D-4579-BDD2-3F815C1AD55F}
     */
    public PropertyManager() {
    }

    /**
     * Method will set the values for all of the properties of the second object to
     * the values of the same properties that are in the first object. <P>Rules followed: <UL>
     * <LI>Assumes that both Objects follow the JavaBeans spec for those properties that are to be copied. </UL>
     * @param <CODE>Object</CODE> The object that has the properties/values to be  copied to the other object.
     * @param <CODE>Object</CODE> The object to copy the properties to.
     * @modelguid {6BE7D4B8-07F5-4D7F-BEDD-AB2F90840D25}
     */
    public static void copyProperties(Object entity1, Object entity2) throws FailedPreconditionException,
        FailedPostconditionException {
            IEvent lEvent = null;
            if (entity1 instanceof IEvent) {
                lEvent = (IEvent)entity1;
            } else if (entity2 instanceof IEvent) {
                lEvent = (IEvent)entity2;
            }
            if (lEvent != null) {
                copyProperties(entity1, entity2, lEvent.getTopic(), getRole(lEvent.getTopic()));
            }
    }

    /**
     * Method will set the values for all of the properties of the second object to
     * the values of the same properties that are in the first object. <P>Rules followed: <UL>
     * <LI>Assumes that both Objects follow the JavaBeans spec for those properties that are to be copied. </UL>
     * @param <CODE>Object</CODE> The object that has the properties/values to be  copied to the other object.
     * @param <CODE>Object</CODE> The object to copy the properties to.
     * @modelguid {E36E0BF1-E3B3-47A5-830D-650805B834A8}
     */
    public static void copyProperties(Object entity1, Object entity2, String serviceName, String role) throws FailedPreconditionException,
        FailedPostconditionException {
            if ((entity1 == null) | (entity2 == null)) {
                return;
            } //end if
            // check for copying to swing container
            boolean isVisualObject = isVisual(entity2);
            // get the contracts for the properties being copied
            IPropertyBundle propertyBundle = getPropertyBundle(serviceName, role);
            if (propertyBundle == null) {
                // if no contract specified, load the default
                propertyBundle = new DefaultPropertyBundle();
            }
            Class c1 = entity1.getClass();
            Class c2 = entity2.getClass();
            // copy process is based on mutator methods, so get all of the public
            // methods for the class to populate
            Iterator mutators = Reflection.getMutatorMethods(c2);
            while (mutators.hasNext()) {
                Method setter = (Method)mutators.next();
                // get property name
                String propertyName = Reflection.getPropertyName(setter);
                IContract contract = new DefaultContract();
                if (!propertyName.equals("")) {
                    // get the contract for the property
                    contract = propertyBundle.getContract(propertyName.substring(0, 1).toLowerCase() +
                        propertyName.substring(1));
                    // apply security for reading the property
                    if (!contract.isReadable()) {
                        if (isVisualObject) {
                            protectProperty(entity2, propertyName);
                        }
                        continue;
                    }
                }
                // construct a call to get the value
                Object value = null;
                if (propertyName.equals("") || propertyName.equals("Topic") || propertyName.equals("Server") ||
                    Reflection.getAccessorMethod(c1, propertyName) == null) {
                        continue;
                }
                try {
                    value = Reflection.invokeAccessorMethod(entity1, propertyName);
                } catch (Throwable t) {
                    continue;
                }

               /* WE SHOULD NOT NEED THIS ANYMORE, LET THE CONTRACT DETERMINE
                // do not process null values
                if (value == null) {
                    continue;
                }
                */

                // apply precondition checks
                contract.checkPrecondition(value);
                // passed precondition checks
                // apply security before setting the property
                if (!contract.isWritable()) {
                    continue;
                }
                Method mutator = Reflection.getMutatorMethod( entity2.getClass(), propertyName, Reflection.getAccessorMethod(c1, propertyName).getReturnType());
                if (mutator == null) {
                    continue;
                }
                try {
                    mutator.invoke( entity2, new Object[] { value } );
                } catch (Throwable t) {}
            } // for
    }

    /**
     *      Builds an Object and sets its state for all properties shared with the inbound HttpServletRequest.
     * <P>Rules followed: <UL> <LI>Assumes that   <LI>The returned Object conforms to the JavaBean spec, ie. has public
     * default constructor and public accessors/mutators for all attributes. </UL>
     *      @param <CODE>HttpServletRequest</CODE> Contains the properties/values to be  copied to the outbound object.
     *      @param <CODE>String</CODE> Fully-qualified classname of the object to create and copy the properties to.
     *      @return <CODE>Object</CODE>.
     *
    public static Object copyProperties(HttpServletRequest req, String className, String serviceName) throws FailedPreconditionException,
        FailedPostconditionException {
            // first check the entity parm
            if ((req == null) | (className == null)) {
                return null;
            }
            Class outClass = null;
            try {
                outClass = Class.forName(className);
            } catch (ClassNotFoundException cnfe) {
                System.out.println(className + " is not a valid class. " + cnfe.getMessage());
                return null;
            }
            // create the instance to be returned
            Object out = null;
            try {
                out = outClass.newInstance();
            } catch (Exception e) {
                System.out.println("error creating an instance of " + outClass.getName() + ". " + e.getMessage());
                return null;
            }
            // now parse out the individual properties
            Enumeration e = req.getParameterNames();
            Method[] methods = outClass.getMethods();
            while (e.hasMoreElements()) {
                String property = (String)e.nextElement();
                //debug System.out.println("property = "+property);
                String value = req.getParameter(property);
                //debug System.out.println("value = "+value);
                // get the setter method for the field
                Method setter = null;
                for (int i = 0; i < methods.length; i++) {
                    String methodName = methods[i].getName();
                    // only process public mutator methods
                    if (Modifier.isPublic(methods[i].getModifiers())) {
                        if (methodName.equals("set" + property.substring(0, 1).toUpperCase() + property.substring(1))) {
                            setter = methods[i];
                            break;
                        }
                    }
                } //end for
                if (setter != null) {
                    // determine type of parameter necessary for setter
                    Class type = setter.getParameterTypes() [0];
                    String typeName = getClassName(type);
                    // create the correct type of object to call setter
                    Object[] parms = new Object[1];
                    // catch any casting exceptions
                    try {
                        if (typeName.equalsIgnoreCase("string")) {
                            parms[0] = value;
                        } else if (typeName.equalsIgnoreCase("date")) {
                            parms[0] = Date.valueOf(value);
                        } else if (typeName.equalsIgnoreCase("timestamp")) {
                            parms[0] = Timestamp.valueOf(value);
                        } else if (typeName.equalsIgnoreCase("integer") || typeName.equalsIgnoreCase("int")) {
                            parms[0] = new Integer(value);
                        } else if (typeName.equalsIgnoreCase("double")) {
                            parms[0] = new Double(value);
                        } else if (typeName.equalsIgnoreCase("float")) {
                            parms[0] = new Float(value);
                        } else if (typeName.equalsIgnoreCase("boolean")) {
                            parms[0] = new Boolean(value);
                        } else if (typeName.equalsIgnoreCase("long")) {
                            parms[0] = new Long(value);
                        } else if (typeName.equalsIgnoreCase("short")) {
                            parms[0] = new Short(value);
                        } else if (typeName.equalsIgnoreCase("char")) {
                            parms[0] = new Character(value.charAt(0));
                        } else if (typeName.equalsIgnoreCase("byte")) {
                        } else {
                            System.err.println("Unexpected type: " + typeName + " found in request.");
                            continue;
                        }
                    } catch (Exception ce) {
                        System.err.println("Error trying to cast <" + value + "> as a " + typeName + ". Property " + property +
                            "'s value was not set.");
                        continue;
                    }
                    try {
                        setter.invoke(out, parms);
                    } catch (IllegalAccessException iae1) {
                        System.err.println("Caught an IllegalAccessException exception: " + iae1.getMessage());
                    } catch (InvocationTargetException ite) {
                        System.err.println("Caught an InvocationTargetException exception: " + ite.getMessage());
                    } //end try
                } else {
                    System.err.println("Method set" + property + " not found.");
                } //end if/else
            } //end while
            return out;
    }

    /**
     * Checks for the existence of the method in the passed class based on the passed method name and arg type.
     * @param <CODE>Object</CODE> Component that contains the method.
     * @param <CODE>String</CODE> Name of property for which to get protect method.
     * @modelguid {F18EDA33-09C5-4E59-8CF7-FA642A4170F9}
     */
    private static void protectProperty(Object component, String propertyName) {
        Class[] parms = new Class[0];
        String methodName = "protect" + propertyName;
        Method m = null;
        // now get the method based on the property name
        try {
            m = component.getClass().getMethod(methodName, parms);
        } catch (NoSuchMethodException nsme) {
            System.err.println("Method " + methodName + " not found in <" + component.getClass() + ">.");
            return;
        }
        // method exists, invoke it
        Object[] args = new Object[0];
        try {
            // set the value for the property
            m.invoke(component, args);
        } catch (IllegalAccessException iae1) {
            System.err.println("Caught an IllegalAccessException. Method <" + methodName + "> : " + iae1.getMessage());
        } catch (InvocationTargetException ite) {
            System.err.println("Caught an InvocationTargetException. Method <" + methodName + "> : " + ite.getMessage());
        } catch (IllegalArgumentException iae) {
            System.err.println("Caught an IllegalArgumentException. Method <" + methodName + "> : " + iae.getMessage());
        } //end try
    }

    /**
     * returns the name of the passed Class after stripping off the package.
     * @param <CODE>Class</CODE>.
     * @return <CODE>String</CODE> Name (not including package) of class that was passed in as a parm.
     * @modelguid {B2B2FA0E-EE40-4D14-AD0D-327E8CE80209}
     */
    private static String getClassName(Class c) {
        String className = c.getName();
        int index = className.lastIndexOf(".");
        return className.substring(index + 1);
    }

    /**
     * determines whether the Class passed in is a user-defined type rather than a Java type.
     * @param <CODE>Class</CODE>.
     * @modelguid {B00F8DC0-622F-4AC3-A76B-8FBCC23DF7B4}
     */
    private static boolean isUserDefinedType(Class type) {
        String typeName = getClassName(type);
        // put non user-defined types into the message
        if (typeName.equalsIgnoreCase("string") || typeName.equalsIgnoreCase("date") ||
            typeName.equalsIgnoreCase("timestamp") || typeName.equalsIgnoreCase("integer") ||
            typeName.equalsIgnoreCase("int") || typeName.equalsIgnoreCase("double") || typeName.equalsIgnoreCase("float") ||
            typeName.equalsIgnoreCase("char") || typeName.equalsIgnoreCase("long") || typeName.equalsIgnoreCase("short") ||
            typeName.equalsIgnoreCase("byte") || typeName.equalsIgnoreCase("boolean")) {
                return false;
        } else {
            return true;
        }
    }

    /**
     * determines whether the Object passed in is a visual (awt, Swing) type.
     * @param <CODE>Object</CODE>.
     * @modelguid {AA2FBCE9-793B-43C5-AA64-E28B4FB4CCA3}
     */
    private static boolean isVisual(Object type) {
        // put non user-defined types into the message
        if (type instanceof java.awt.Container) {
            return true;
        } else {
            return false;
        }
    }

    /**
     * loads a property bundle (set of contracts) based on the serviceName and role.
     * @param <CODE>String</CODE>.
     * @param <CODE>String</CODE>.
     * @return <CODE>IPropertyBundle</CODE>.
     * @modelguid {A04B64F3-7DA3-4FF8-AD2E-2509C484972F}
     */
    public static IPropertyBundle getPropertyBundle(String serviceName, String role) {
        if (serviceName == null || serviceName.equals("")) {
            return null;
        }
        String key = serviceName;
        // it's possible to have a property bundle based on service topic only, so
        // add role only if it applies
        if (role == null) {
            return null;
        } else if (!role.equals("")) {
            key += "_" + role;
        }
        IPropertyBundle retVal = null;
        if (bundles.containsKey(key)) {
            return (IPropertyBundle)bundles.get(key);
        } else {
            Class aClass = null;
            String className = null;
            try {
                className = PropertyBundleProperties.getInstance().getProperty(key);
                //if (className != null && !className.equals("") {
                aClass = Class.forName(className);
                //}
            } catch (Exception x) {
                //System.out.println("Unable to load Property Bundle :: " + className + ". Key is <"+key+">");
            }
            if (aClass != null) {
                try {
                    retVal = (IPropertyBundle)aClass.newInstance();
                    bundles.put(key, retVal);
                } catch (Exception e) {
                    System.out.println("\nUnable to create Property Bundle :: " + className + ".");
                    e.printStackTrace();
                }
            }
            return retVal;
        }
    }

    /**
     * determines the highest priority role for a user for a service.
     * @param <CODE>String</CODE> - service name.
     * @return <CODE>String</CODE> - role that has highest priority for service.
     * @modelguid {EEB27B41-6207-4C31-9879-05D42781A14F}
     */
    private static String getRole(String service) {
        //String[] role = {""};
        String[] role = {"AccountManager"};
        if (service != null) {
      //      SecurityManager.getSharedInstance().hasPermission(service, role);
        }
        return role[0];
    }

    /**
     * Invoke methods with properties from input bean object.  It will copy properties out of bean and invoke the given method
     * of a class with parameters that are named in common with the property names.
     * @param inObject - bean object
     * @param invokedObject - object to invoke behavior on
     * @param parameterNames - a Vector of the parameter names of values being passed to the invokedObject.
     * @param methodName - name of method to be invoked
     * @modelguid {BBDE0FE5-ECBD-46B5-A1AF-68886D7A3C39}
     */
    static public void invokeWithBean(Object inObject, Object invokedObject, Vector parameterNames, String methodName) {
        if ((inObject == null) | (invokedObject == null)) {
            return;
        } //end if
        Class c1 = inObject.getClass();
        Class c2 = invokedObject.getClass();
        // copy process is based on mutator methods, so get all of the public
        // methods for the class to populate
        Method[] methods = c2.getMethods();
        Method invokedMethod = null;
        for (int i = 0; i < methods.length; i++) {
            if (methods[i].getName().equals(methodName)) {
                invokedMethod = methods[i];
            }
        }
        if (invokedMethod == null) {
            return;
        }
        Class[] parmsC = invokedMethod.getParameterTypes();
        if (parmsC.length != parameterNames.size()) {
            throw new RuntimeException("Not a valid list of parameter names.");
        }
        Object[] parms = new Object[parmsC.length];
        for (int i = 0; i < parmsC.length; i++) {
            String paramName = (String)parameterNames.elementAt(i);
            //cArray[0] = methods[i].getReturnType();
            // get property name
            String propertyName = paramName.substring(0, 1).toUpperCase() + paramName.substring(1);
            // get the accessor for the property
            Class[] cArray = new Class[0];
            Method getter = null;
            try {
                getter = c1.getMethod("get" + propertyName, cArray);
            } catch (Throwable t) {
                //System.err.println(t.getMessage());
            }
            if (getter != null) {
                // construct a call to get the value
                Object[] args = new Object[0];
                Object value = null;
                try {
                    value = getter.invoke(inObject, args);
                } catch (Throwable iae) {
                    //System.err.println("Caught an Exception exception: "+iae.getMessage());
                }

                /* WE SHOULD NOT NEED THIS ANYMORE, LET THE CONTRACT DETERMINE
                // do not process null values
                if (value == null) {
                    continue;
                }
                */

                parms[i] = value;
            } // if
        } // for
        try {
            invokedMethod.invoke(invokedObject, parms);
        } catch (IllegalAccessException iae1) {
            //System.err.println("Caught an IllegalAccessException. Method <set" + propertyName + "> : " +
            //iae1.getMessage());
        } catch (InvocationTargetException ite) {
            //System.err.println("Caught an InvocationTargetException. Method <set" + propertyName +
            //"> : " + ite.getMessage());
        } catch (IllegalArgumentException iae) {
            //System.err.println("Caught an IllegalArgumentException. Method <set" + propertyName +
            //"> : " + iae.getMessage());
        } // try
    }

	/** @modelguid {6E60F574-A32F-49CC-80B7-89D1B1B5BDBF} */
    static Hashtable bundles = new Hashtable();
}
