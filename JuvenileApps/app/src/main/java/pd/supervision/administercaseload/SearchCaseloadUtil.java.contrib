package pd.supervision.administercaseload;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import messaging.administercaseload.GetCaseloadByDefendantEvent;
import messaging.administercaseload.GetCaseloadByDefendentsAndProgramUnitEvent;
import messaging.administercaseload.GetCaseloadByOfficerEvent;
import messaging.administercaseload.GetCaseloadEvent;
import messaging.administercaseload.domintf.ICaseAssignment;
import messaging.administercaseload.reply.CaseAssignmentResponseEvent;
import messaging.calendar.GetCalendarByDefendantIdsEvent;
import mojo.km.utilities.DateUtil;
import mojo.km.utilities.MessageUtil;
import naming.PDCodeTableConstants;
import pd.supervision.administerserviceprovider.administerlocation.Quadrant;
import pd.supervision.cscdcalendar.CSEvent;

public class SearchCaseloadUtil
{
    /**
     * @roseuid 464DAC3F0391
     */
    public SearchCaseloadUtil()
    {

    }
    
    protected List getCaseloadByOfficer(GetCaseloadEvent event){
        List results = new ArrayList();
    	GetCaseloadByOfficerEvent officer = new GetCaseloadByOfficerEvent();
        officer.setOfficerPositionId(event.getOfficerPositionId());
    	Iterator iter = CaseAssignmentOrder.findAllByOfficerEvent(officer);
    	Map map = new HashMap();
    	while(iter.hasNext()){
    		CaseAssignmentOrder co = (CaseAssignmentOrder) iter.next();
    		if(!map.containsKey(co.getDefendantId() + co.getCriminalCaseId())){
    			map.put(co.getDefendantId() + co.getCriminalCaseId(), co);
    		}
    	}
    	
    	if(!map.isEmpty()){
    		results = new ArrayList(map.values());
    	}
    	return results;
    }
    
    protected List getCaseloadByDefendantId(GetCaseloadEvent event){
        List results = new ArrayList();
    	GetCaseloadByDefendantEvent defEvent = new GetCaseloadByDefendantEvent();
    	String defendantId = event.getDefendantId();
    	if(defendantId != null && defendantId.length() < 8){
    		while(defendantId.length() < 8){
    			defendantId = "0" + defendantId;
    		}
    	}
    	defEvent.setDefendantId(defendantId);
    	Iterator iter = CaseAssignmentOrder.findAllByOfficerEvent(defEvent);
    	Map map = new HashMap();
    	while(iter.hasNext()){
    		CaseAssignmentOrder co = (CaseAssignmentOrder) iter.next();
    		if(!map.containsKey(co.getDefendantId() + co.getCriminalCaseId())){
    			map.put(co.getDefendantId() + co.getCriminalCaseId(), co);
    		}
    	}
    	if(!map.isEmpty()){
    		results = new ArrayList(map.values());
    	}
    	return results;
    }
    
    protected List getCaseloadByQuadrantId(GetCaseloadEvent event){
        List results = new ArrayList();
    	List list = Quadrant.findAll("quadrantCd",event.getQuadrantId());
    	String organizationId = "";
        StringBuffer defendantIds = new StringBuffer("");
    	for(int i=0;i<list.size();i++){
    		Quadrant quad = (Quadrant) list.get(i);
    		defendantIds.append("'");
    		defendantIds.append(quad.getDefendantId());
    		defendantIds.append("'");
    		if(i != list.size() -1){
    			defendantIds.append(",");
    		}
    		organizationId = "" + quad.getOrganizationId();
    	}
    	
    	Map map = new HashMap();
    	if(defendantIds.toString().length() > 0){
	    	GetCaseloadByDefendentsAndProgramUnitEvent gEvent = new GetCaseloadByDefendentsAndProgramUnitEvent();
	    	gEvent.setDefendantIds(defendantIds.toString());
	    	gEvent.setProgramUnit(organizationId);
	    	Iterator iter = CaseAssignmentOrder.findAllByEvent(gEvent);
	    	while(iter.hasNext()){
	    		CaseAssignmentOrder co = (CaseAssignmentOrder) iter.next();
	    		if(!map.containsKey(co.getDefendantId() + co.getCriminalCaseId())){
	    			map.put(co.getDefendantId() + co.getCriminalCaseId(), co);
	    		}
	    	}
    	}
    	if(!map.isEmpty()){
    		results = new ArrayList(map.values());
    	}
    	return results;
    }
    
    protected List getCaseloadByZipCode(GetCaseloadEvent event){
        List results = new ArrayList();
    	Iterator iterator = SuperviseeZipCode.findAll("zipCode",event.getZipCode());
    	StringBuffer defendantIds = new StringBuffer("");
    	String organizationId = "";
    	while(iterator.hasNext()){
    		SuperviseeZipCode sz = (SuperviseeZipCode) iterator.next();
    		defendantIds.append("'");
    		defendantIds.append(sz.getDefendantId());
    		defendantIds.append("'");
    		if(iterator.hasNext()){
    			defendantIds.append(",");
    		}
    		organizationId = "" + sz.getOrganizationId();
    	}
    	
    	Map map = new HashMap();
    	if(defendantIds.toString().length() > 0){
	    	GetCaseloadByDefendentsAndProgramUnitEvent gEvent = new GetCaseloadByDefendentsAndProgramUnitEvent();
	    	gEvent.setDefendantIds(defendantIds.toString());
	    	gEvent.setProgramUnit(organizationId);
	    	Iterator iter = CaseAssignmentOrder.findAllByEvent(gEvent);
	    	while(iter.hasNext()){
	    		CaseAssignmentOrder co = (CaseAssignmentOrder) iter.next();
	    		if(!map.containsKey(co.getDefendantId() + co.getCriminalCaseId())){
	    			map.put(co.getDefendantId() + co.getCriminalCaseId(), co);
	    		}
	    	}
    	}
    	if(!map.isEmpty()){
    		results = new ArrayList(map.values());
    	}
    	return results;
    }

    /**
     * @param results
     * @return
     */
    protected void sendBySupervisee(List results)
    {
        ActiveCaseAssignmentBuilder builder = new ActiveCaseAssignmentBuilder();
        Map resultsBySupervisee = new HashMap();

        // iterate results and separate by supervisee (defendantId)
        StringBuffer str = new StringBuffer();
        for (int i = 0; i < results.size(); i++) {
            CaseAssignmentOrder activeCaseAssignment = (CaseAssignmentOrder) results.get(i);            
            str.append("'");
            str.append(activeCaseAssignment.getDefendantId());
            str.append("',");
        }
        
        if(str.toString().length() < 2){
        	return;
        }
        
        String defendantIds = str.toString().substring(0,str.toString().length() - 1);
        Map superviseeMap = Supervisee.getSuperviseesByIds(defendantIds);
        
        GetCalendarByDefendantIdsEvent gcEvent = new GetCalendarByDefendantIdsEvent();
        gcEvent.setDefendantIds(defendantIds);
        Map csEventMap = new HashMap();
        Iterator iterCSEvent = CSEvent.findAll(gcEvent);
        while(iterCSEvent.hasNext()){
        	CSEvent csEvent = (CSEvent) iterCSEvent.next();
        	
        	List list = (List) csEventMap.get(csEvent.getPartyId());
        	if (list != null) 
        	{
        		list.add(csEvent);
        		csEventMap.put(csEvent.getPartyId(), list);
        	} 
        	else
        	{
        		list = new ArrayList();
        		list.add(csEvent);
        		csEventMap.put(csEvent.getPartyId(), list);
        	}
        		
        }
        
        for (int i = 0; i < results.size(); i++) {
            CaseAssignmentOrder activeCaseAssignment = (CaseAssignmentOrder) results.get(i); 
            Supervisee supervisee = (Supervisee) superviseeMap.get(activeCaseAssignment.getDefendantId());
            if (supervisee != null && supervisee.isCurrentlySupervised()) {
                builder.setActiveCaseAssignment(activeCaseAssignment);
                builder.build();
                ICaseAssignment assignmentBean = (ICaseAssignment) builder.getResult();
            	CaseAssignmentResponseEvent response = (CaseAssignmentResponseEvent) resultsBySupervisee.get(activeCaseAssignment.getDefendantId());
                if (response == null) { 
                    response = createResponse(assignmentBean, supervisee, activeCaseAssignment, csEventMap);
                    resultsBySupervisee.put(activeCaseAssignment.getDefendantId(), response);
                } else {
                	response.addCaseAssignment(assignmentBean);            	
                }
            }
        }    
        
        //Clear HashMap
        csEventMap.clear();
        
        Collection responses = resultsBySupervisee.values();
        for (Iterator iterator = responses.iterator(); iterator.hasNext();) {
        	CaseAssignmentResponseEvent responseEvent = (CaseAssignmentResponseEvent) iterator.next();
        	List activeCases = responseEvent.getCaseAssignments();
        	String daysLeft = getMinOfDaysLeft(activeCases);
        	responseEvent.setDaysLeft(daysLeft);
        	
            MessageUtil.postReply(responseEvent);        	
        }
    }

    /**
     * @param assignmentBean
     * @return
     */
    private CaseAssignmentResponseEvent createResponse(ICaseAssignment assignmentBean, Supervisee supervisee, CaseAssignmentOrder caOder, Map csEventMap)
    {
        CaseAssignmentResponseEvent response = new CaseAssignmentResponseEvent();
        response.setDefendantId(assignmentBean.getDefendantId());
        response.setDefendantFullName(caOder.getDefendantName());
        response.setWarrantIndicator(caOder.getWarrantInd());
        response.setJailIndicator(caOder.getJailInd());
        setSupervisionDates(response, csEventMap);        
        response.addCaseAssignment(assignmentBean);
        
        response.setZipCode(supervisee.getZipCode());
        String levelOfSupervision = supervisee.getSupervisionLevelId();
		if(levelOfSupervision != null && !"".equals(levelOfSupervision)){
			SupervisionLevelOfServiceCode supervisionLevelCode = SupervisionLevelOfServiceCode.find(levelOfSupervision);
			if(supervisionLevelCode != null){
				String legacyCodeForLevelOfService = supervisionLevelCode.getLevelOfServiceLegacyCode();
				response.setLevelOfSupervision(legacyCodeForLevelOfService);
			}
		}        
        return response;
    }
    
	private String getMinOfDaysLeft(List cases) {
		long minValue = 0;	
		boolean firstTime = true;
		for (Iterator iterator = cases.iterator(); iterator.hasNext();) {
			ICaseAssignment caseAssignment = (ICaseAssignment) iterator.next();
			long daysLeft = caseAssignment.getDaysLeft();
			if (firstTime) {
				minValue = daysLeft;
				firstTime = false;
			}
			minValue = Math.min(minValue, daysLeft);
		}
		return String.valueOf(minValue);
	}
	
	private void setSupervisionDates(CaseAssignmentResponseEvent response, Map csEventMap) {
		String defendantId = response.getDefendantId(); 
		long lastFaceToFaceInMillis = 0L;
		long nextOfficeVisitInMillis = 0L;
		Date lastFaceToFaceDate = null;
		Date nextOfficeVisitDate = null;
		Calendar calendar = Calendar.getInstance();
		//No hours:minutes:seconds information is stored in event date. The following transformations
		//are done to remove the hours:minutes:seconds information from current date.
		Date today = DateUtil.stringToDate(DateUtil.dateToString(calendar.getTime(), DateUtil.DATE_FMT_1), 
				DateUtil.DATE_FMT_1);
		calendar.setTime(today);
		long currentTimeInMillis = calendar.getTimeInMillis();
		boolean firstTime = true;

		List list = (List) csEventMap.get(defendantId);
		if(list != null && !list.isEmpty()){
			Iterator results = list.iterator();
			for (;results.hasNext();) {
				CSEvent defendantEvent = (CSEvent) results.next();			
				String eventTypeId = defendantEvent.getEventTypeId();
				String outcome = defendantEvent.getOutCome();
				Date eventDate = defendantEvent.getEventDate();
				calendar.setTime(eventDate);
				long eventDateInMillis = calendar.getTimeInMillis();
				
				if (eventTypeId.equals(PDCodeTableConstants.CS_OFFICE_VISIT_TYPE)
						|| eventTypeId.equals(PDCodeTableConstants.CS_GROUP_OFFICE_VISIT_TYPE)) {
					if (PDCodeTableConstants.OV_OUTCOME_ATTENDED.equals(outcome) && 
							eventDateInMillis <= currentTimeInMillis) {
						lastFaceToFaceInMillis = Math.max(lastFaceToFaceInMillis, eventDateInMillis);					
						calendar.setTimeInMillis(lastFaceToFaceInMillis);	
						lastFaceToFaceDate = calendar.getTime();
					} else if (PDCodeTableConstants.OTHER_AND_FV_OUTCOME_SCHEDULED.equals(outcome) &&
							eventDateInMillis >= currentTimeInMillis) {
						if (firstTime) {
							nextOfficeVisitInMillis = eventDateInMillis;
							firstTime = false;
						} else {
							nextOfficeVisitInMillis = Math.min(nextOfficeVisitInMillis, eventDateInMillis);											
						}
						calendar.setTimeInMillis(nextOfficeVisitInMillis);
				        nextOfficeVisitDate = calendar.getTime();        
					}
				} else if (eventTypeId.equals(PDCodeTableConstants.CS_FIELD_VISIT_CATEGORY)) {
					if (PDCodeTableConstants.OTHER_AND_FV_OUTCOME_COMPLETE.equals(outcome) &&
							eventDateInMillis <= currentTimeInMillis) {
						lastFaceToFaceInMillis = Math.max(lastFaceToFaceInMillis, eventDateInMillis);										
						calendar.setTimeInMillis(lastFaceToFaceInMillis);	
						lastFaceToFaceDate = calendar.getTime();
					}
				}
			}
		}
        response.setLastFaceToFaceDate(lastFaceToFaceDate);
        response.setNextOfficeVisitDate(nextOfficeVisitDate);
	}
}
