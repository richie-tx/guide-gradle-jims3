package ui.juvenilecase;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import ui.common.Name;
import ui.security.SecurityUIHelper;
import messaging.juvenilecase.reply.RiskAnswerResponseEvent;
import messaging.juvenilecase.reply.RiskQuestionResponseEvent;
import messaging.juvenilecase.reply.RiskWeightedResponseEvent;
import messaging.riskanalysis.RiskQuestionAnswerEvent;
import mojo.km.messaging.Composite.CompositeResponse;
import mojo.km.security.IUserInfo;
import mojo.km.utilities.DateUtil;
import mojo.km.utilities.MessageUtil;
import naming.RiskAnalysisConstants;
import naming.UIConstants;

public class UIRiskAnalysisHelper
{
	/**
	 * DRAFT IMPLEMENTATIon! NEEDS TO BE RE-WORKED/IMPROVED FOR MULTIPLE AND
	 * CHRONIC ANSWERS Merges User responses with their respective Questions for
	 * display
	 *  
	 * @param responseGroupIter
	 * @param questionAnswerGroupIter
	 * @return
	 */
	public static List mergeUserReponsesWithQuestions( 
			RiskQuestionResponseEvent[] riskQuestionResponseEvents, 
			RiskAnswerResponseEvent[] riskAnswerResponseEvents )
	{
		List finalList = new ArrayList(); // Final List of Questions & Answers

		for(int i = 0; i < riskQuestionResponseEvents.length; i++)
		{
			RiskQuestionResponseEvent question = riskQuestionResponseEvents[i];

			for(int j = 0; j < riskAnswerResponseEvents.length; j++)
			{
				RiskAnswerResponseEvent response = riskAnswerResponseEvents[j];

				int reQuestionID = 0 ;
				try
				{
					reQuestionID = Integer.parseInt( response.getQuestionID() ) ;
				}
				catch( NumberFormatException nfe )
				{
					reQuestionID = 0 ;
				}
				
				if( question.getQuestionID() ==  reQuestionID )
				{
					//A CHECKBOX UIControlType means there are possible multiple answers
					//for the questions.
					if (question.getUiControlType().equalsIgnoreCase(UIConstants.CHECKBOX) || question.getUiControlType().equalsIgnoreCase(UIConstants.CHECKBOXWITHCHRONIC)) {
						
						//Means the SelectedAnswerIDs array has not yet been populated.
						if (question.getSelectedAnswerIDs() == null) {
							String[] selectedAnswerIDs = new String[1];
							String selectedAnswerID = response.getWeightID();
						    
							
							selectedAnswerIDs[0] = selectedAnswerID;
							question.setSelectedAnswerIDs(selectedAnswerIDs);
							question.setSelectedAnswerWeight( String.valueOf(response.getWeight() ) );
						
						//Means the SelectedAnswerIDs array has already been populated.
						// The following code adds to this array.
						} else {
								
							/** The code below in this "else" is in prototype mode, will not know if it works until used with a question
							*   that has multiple possible answers.
							**/
							int oldSelectedAnswerIDsArrayLength = question.getSelectedAnswerIDs().length;
							int newSelectedAnswerIDsArrayLength = 1 + oldSelectedAnswerIDsArrayLength;
							int newSelectedAnswerIDPosition = newSelectedAnswerIDsArrayLength - 1;
							int totalWeight = Integer.parseInt(question.getSelectedAnswerWeight());
							
							String[] newSelectedAnswerIDsArray = new String[newSelectedAnswerIDsArrayLength];
							String[] oldSelectedAnswerIDsArray = question.getSelectedAnswerIDs();
							
							//Takes values from old array and places them into new array.
							for(int v = 0; v < oldSelectedAnswerIDsArray.length; v++) {
								newSelectedAnswerIDsArray[v] = oldSelectedAnswerIDsArray[v];
							}
							
							newSelectedAnswerIDsArray[newSelectedAnswerIDPosition] = response.getWeightID();
							
							question.setSelectedAnswerIDs(newSelectedAnswerIDsArray);
							
							totalWeight = totalWeight + response.getWeight();						    
							question.setSelectedAnswerWeight( String.valueOf(totalWeight) );
							
						}
						
					} else {
						question.setSelectedAnswerID( response.getWeightID() );
						question.setSelectedAnswerWeight( String.valueOf(response.getWeight() ) );
					}
					break;
				}
			}

			finalList.add( question );
		}

		return finalList;
	}

	/**
	 * Called by the Interview Assessment Action
	 * 
	 * @param response
	 * @return
	 */
	public static List groupQuestionsAndAnswers( CompositeResponse response )
	{
		List questions = MessageUtil.compositeToList( response, RiskQuestionResponseEvent.class );
		Collections.sort( questions );
		List answers = MessageUtil.compositeToList( response, RiskWeightedResponseEvent.class );

		Iterator<RiskWeightedResponseEvent> ite = answers.iterator();
		RiskWeightedResponseEvent answer;
		RiskQuestionResponseEvent question;
		while(ite.hasNext())
		{
			answer = ite.next();
			String questionID = answer.getRiskQuestionsId();
			question = filterQuestionByID( questionID, questions );
			if( question != null )
			{
				question.addAnswer( answer );
			}
		}

		Iterator<RiskQuestionResponseEvent> iteQues = questions.iterator();
		while(iteQues.hasNext())
		{
			RiskQuestionResponseEvent sortedQuestion = iteQues.next();
			Collections.sort( (ArrayList)sortedQuestion.getAnswers() );
		}

		return questions;
	}

	/*
	 * 
	 */
	private static RiskQuestionResponseEvent filterQuestionByID( String id, Collection questions )
	{
		RiskQuestionResponseEvent riskQuestionResponseEvent = null;
		Iterator<RiskQuestionResponseEvent> qIte = questions.iterator();
		while(qIte.hasNext())
		{
			RiskQuestionResponseEvent tempRiskQuestionResponseEvent = qIte.next();
			String qId = Integer.toString( tempRiskQuestionResponseEvent.getQuestionID() );
			if( qId.equals( id ) )
			{
				riskQuestionResponseEvent = tempRiskQuestionResponseEvent;
				break;
			}
		}
		
		return riskQuestionResponseEvent;
	}

	/*
	 * 
	 */
	public static String getTestingPageTitle( List qans, int questionNum )
	{
		String pageTitle = "";
		try
		{
			RiskQuestionAnswerEvent qa = (RiskQuestionAnswerEvent)qans.get( questionNum +1 );
			if( qa != null )
			{
				pageTitle = qa.getQuestionText();
			}
		}
		catch( IndexOutOfBoundsException ioobe )
		{ // there's the possibility the index is wacked out,
			// so just leave the pageTitle as is.
		}
		
		return pageTitle;
	}

	/**
	 * Takes in a List of RiskQuestionResponseEvents and converts them into a list
	 * of veiw only RiskQuestionAnswerEvent consolidated by Question number based
	 * on the question number
	 * 
	 * @param riskQuestionResponseEvents
	 * @return
	 */
	public static List viewOnlyMultiQuestionAnswers( List riskQuestionResponseEvents )
	{
		List riskQuestionAnswerEvents = new ArrayList();

		// Create temporary hashmap to hold Question/Answers until they are processed
		HashMap map = new HashMap();

		// Iterate through RiskQuestionResponseEvents 
		// (User responses to Questions), one by one.
		Iterator<RiskQuestionAnswerEvent> ite = riskQuestionResponseEvents.iterator();
		while(ite.hasNext())
		{
			RiskQuestionAnswerEvent singleProcessedRiskQuestionAnswerEvent = ite.next();

			// Create new Question/Answer
			RiskQuestionAnswerEvent newRiskQuestionAnswerEvent = new RiskQuestionAnswerEvent();

			// Find out if answer is chronic
			boolean isChronic = (singleProcessedRiskQuestionAnswerEvent.getText() != null && 
					singleProcessedRiskQuestionAnswerEvent.getText().equals( UIConstants.ISCHRONIC ) ) ;
			
			String strAnwserText;
			if (singleProcessedRiskQuestionAnswerEvent.getAnswerText() == null) {
				strAnwserText = "";
			} else {
				strAnwserText = singleProcessedRiskQuestionAnswerEvent.getAnswerText();
			}

			{ StringBuffer answerText = new StringBuffer( strAnwserText );
				//Checks to see if the controlCode is empty, if not this means it's not a true chronic answer
				//rather it's other free text
				if( isChronic && (singleProcessedRiskQuestionAnswerEvent.getControlCode() == null 
						|| (singleProcessedRiskQuestionAnswerEvent.getControlCode() != null && singleProcessedRiskQuestionAnswerEvent.getControlCode().length() < 1) ) )
				{
					answerText.append( " [Chronic] " );
				}
				newRiskQuestionAnswerEvent.setAnswerText( answerText.toString() );
			}
			
			newRiskQuestionAnswerEvent.setQuestionText( singleProcessedRiskQuestionAnswerEvent.getQuestionText() );
			newRiskQuestionAnswerEvent.setQuestionNumber( singleProcessedRiskQuestionAnswerEvent.getQuestionNumber() );
			newRiskQuestionAnswerEvent.setUiControlType( singleProcessedRiskQuestionAnswerEvent.getUiControlType() );

			// Checks to see if Question/Answer already exist in hashmap
			RiskQuestionAnswerEvent priorRiskQuestionAnswerEvent = (RiskQuestionAnswerEvent)
					map.get( singleProcessedRiskQuestionAnswerEvent.getQuestionNumber() );

			// Consolidates Question/Answer if it existed in hashmap
			if( priorRiskQuestionAnswerEvent != null )
			{
				// Add New Answer Text To Answer Text
				StringBuffer answerTextsForQuestionNumber = new StringBuffer();
				answerTextsForQuestionNumber.append( priorRiskQuestionAnswerEvent.getAnswerText() ).append( ", " ).append( singleProcessedRiskQuestionAnswerEvent.getAnswerText() );

				// Add isChronic to answer when needed
				if( isChronic )
				{
					answerTextsForQuestionNumber.append( " [Chronic] " );
				}

				// Set consolidated answer text for viewing purposes
				priorRiskQuestionAnswerEvent.setAnswerText( answerTextsForQuestionNumber.toString() );

				// Place new consolidated Question/Answer in hashmap
				map.put( singleProcessedRiskQuestionAnswerEvent.getQuestionNumber(), priorRiskQuestionAnswerEvent );
			}
			else
			{
				// Place new Question/Answer in hashmap
				map.put( singleProcessedRiskQuestionAnswerEvent.getQuestionNumber(), newRiskQuestionAnswerEvent );
			}
		} // while

		// Move Question/Answers to list
		Collection c = map.values();
		Iterator<RiskQuestionAnswerEvent> itr = c.iterator();
		while(itr.hasNext())
		{
			riskQuestionAnswerEvents.add( itr.next() );
		}

		return riskQuestionAnswerEvents;
	}

	/**
	 * Takes in a List of RiskQuestionResponseEvents and converts them into a list
	 * of individual RiskQuestionAnswerEvent ready to send to back-end for further
	 * PD processing
	 * 
	 * @param riskQuestionResponseEvents
	 * @return
	 */
	public static List processIndividualQuestionAnswers( List riskQuestionResponseEvents )
	{
		List weightResponses = new ArrayList();
		// Iterate through RiskQuestionResponseEvents (User responses to Questions), one by one.
		Iterator<RiskQuestionResponseEvent> ite = riskQuestionResponseEvents.iterator();

		while(ite.hasNext())
		{
			/* RiskQuestionResponseEvent: The Question, Possible Answer(s),
			 * Selected Answers(s), and Possible Selected Chronic Answer(s)
			 * Single Response Event
			 */
			RiskQuestionResponseEvent riskQuestionResponseEvent = ite.next();

			// All Questions have a UIControlType
			String controlType = riskQuestionResponseEvent.getUiControlType();

			/* A UiControlType of NOANSNEEDED, means the RiskQuestionResponseEvent
			 * is not a question from the database and carries no valid weight id
			 * In other words, it's a static question created in the application.
			 */
			if( !controlType.equalsIgnoreCase( UIConstants.NOANSNEEDED ) )
			{
				// Possible Answers to the Question
				RiskWeightedResponseEvent[] riskWeightedResponseEvents = (RiskWeightedResponseEvent[])
						riskQuestionResponseEvent.getAnswers().toArray( new RiskWeightedResponseEvent[ riskQuestionResponseEvent.getAnswers().size() ] );

				if( controlType.equalsIgnoreCase( UIConstants.DATE ) || 
						controlType.equalsIgnoreCase( UIConstants.TEXTBOX ) || 
						controlType.equalsIgnoreCase( UIConstants.TEXTAREA ) )
				{
					// Create a single RiskQuestionAnswerEvent
					// Single Answer Event
					RiskQuestionAnswerEvent riskQuestionAnswerEvent = new RiskQuestionAnswerEvent();

					riskQuestionAnswerEvent.setUiControlType( riskQuestionResponseEvent.getUiControlType() );
					riskQuestionAnswerEvent.setControlCode( riskQuestionResponseEvent.getControlCode() );
					riskQuestionAnswerEvent.setQuestionNumber( riskQuestionResponseEvent.getQuestionNbr() );
					riskQuestionAnswerEvent.setQuestionText( riskQuestionResponseEvent.getQuestionText() );

					/* A UiControlType of DATE, TEXTAREA, TEXTBOX will have a single
					 * riskWeightedResponseEvent in answers collection of
					 * riskQuestionResponseEvent. Use it to get weight of response.
					 */
					int weightedResponseID = riskWeightedResponseEvents[0].getWeightedResponseID();
					riskQuestionAnswerEvent.setWeightedResponseID( weightedResponseID );

					/* A UiControlType of DATE, TEXTAREA, TEXTBOX will store
					 * the date or text in the selectedAnswerID of
					 * the riskQuestionAnswerEvent
					 */
					String textOrDate = riskQuestionResponseEvent.getSelectedAnswerID();

					// A UiControlType needs to have the date attached
					if( controlType.equalsIgnoreCase( UIConstants.TEXTAREA ) )
					{
						// Tags Date to the end of TEXTAREA content
						IUserInfo user = SecurityUIHelper.getUser();
						Name userName = new Name( user.getFirstName(), UIConstants.EMPTY_STRING, user.getLastName() );
						// textOrDate = textOrDate + " [" +
						// DateUtil.getCurrentDateString(UIConstants.DATETIME24_FMT_1) +
						// " - " + userName.getFormattedName() + "]";
						textOrDate = new StringBuilder( textOrDate ).append( " [" ).append( DateUtil.getCurrentDateString( UIConstants.DATETIME24_FMT_1 ) ).append( " - " ).append( userName.getFormattedName() ).append( "]" ).toString();
					}

					riskQuestionAnswerEvent.setText( textOrDate );
					riskQuestionAnswerEvent.setAnswerText( textOrDate );

					// Add to List
					if (textOrDate != null && textOrDate.length() > 0) {
						weightResponses.add( riskQuestionAnswerEvent );
					}
				}
				else if( controlType.equals( UIConstants.LISTBOX ) || 
						controlType.equals( UIConstants.CHECKBOX ) || 
						controlType.equals( UIConstants.CHECKBOXWITHCHRONIC ))
				{
					
					//Run for single checkbox question
					/*
					if ( (riskQuestionResponseEvent.getSelectedAnswerID() != null && riskQuestionResponseEvent.getSelectedAnswerID().length() > 0 ) &&
							(riskQuestionResponseEvent.getSelectedAnswerIDs() == null || (riskQuestionResponseEvent.getSelectedAnswerIDs() != null && riskQuestionResponseEvent.getSelectedAnswerIDs().length == 0) )) {
						
						String[] selectedAnswerIDs = new String[1];
						selectedAnswerIDs[0] = riskQuestionResponseEvent.getSelectedAnswerID();
						riskQuestionResponseEvent.setSelectedAnswerIDs(selectedAnswerIDs);
						
					}
					*/
					
					// If it is a multi select box then need to get all the selected answer id's
					String[] selectedAnswerIDs = riskQuestionResponseEvent.getSelectedAnswerIDs();
					String[] selectedChronicIDs = riskQuestionResponseEvent.getSelectedChronicIDs();

					if( selectedAnswerIDs != null )
					{
						// Outer Loop Through AnswerIds
						for(int i = 0; i < selectedAnswerIDs.length; i++)
						{
							// Create a single RiskQuestionAnswerEvent
							// Single Answer Event
							RiskQuestionAnswerEvent riskQuestionAnswerEvent = new RiskQuestionAnswerEvent();

							int weightedResponseID = 0 ;
							try
							{
								weightedResponseID = Integer.parseInt( selectedAnswerIDs[i] );
							}
							catch( NumberFormatException nfe )
							{
								weightedResponseID = 0;
							}
							
							// Set responseWeightId on riskQuestionAnswerEvent
							riskQuestionAnswerEvent.setWeightedResponseID( weightedResponseID );

							riskQuestionAnswerEvent.setUiControlType( riskQuestionResponseEvent.getUiControlType() );

							riskQuestionAnswerEvent.setQuestionNumber( riskQuestionResponseEvent.getQuestionNbr() );
							riskQuestionAnswerEvent.setQuestionText( riskQuestionResponseEvent.getQuestionText() );

							// Set AnswerText on riskQuestionAnswerEvent
							for(int k = 0; k < riskWeightedResponseEvents.length; k++)
							{
								int possibleSelectedWeightResponseid = riskWeightedResponseEvents[k].getWeightedResponseID();
								int possibleSelectedWeightResponse = riskWeightedResponseEvents[k].getWeight();
								String possibleSelectedWeightResponseText = riskWeightedResponseEvents[k].getAnswerText();

								if( weightedResponseID == possibleSelectedWeightResponseid )
								{
									riskQuestionAnswerEvent.setWeight( possibleSelectedWeightResponse );
									riskQuestionAnswerEvent.setAnswerText( possibleSelectedWeightResponseText );
									break;
								}
							}

							if( selectedChronicIDs != null )
							{
								for(int j = 0; j < selectedChronicIDs.length; j++)
								{
									int chronicWeightedResponseID = 0;
									
									try
									{
										chronicWeightedResponseID = Integer.parseInt( selectedChronicIDs[j] );
									}
									catch( NumberFormatException nfe )
									{
										chronicWeightedResponseID = 0;
									}
									
									if( weightedResponseID == chronicWeightedResponseID )
									{
										// Chronic Adds +1 to the weight which is needed
										// for some risk computations
										riskQuestionAnswerEvent.setText( UIConstants.ISCHRONIC );
										riskQuestionAnswerEvent.setWeight( riskQuestionAnswerEvent.getWeight() + 1 );
										break;
									}
								} // End Inner Loop
							}

							weightResponses.add( riskQuestionAnswerEvent );
						} // End Outer Loop
					}// End selectedAnswerIDs IF
				}
				else if( controlType.equals( UIConstants.RADIO ) || 
						controlType.equals( UIConstants.DROPDOWN ) ||
						controlType.equals( UIConstants.QUESTIONHEADER ))
				{
					int weightedResponseID = 0;
					if( riskQuestionResponseEvent.getSelectedAnswerID() != null )
					{
						try
						{
							weightedResponseID = Integer.parseInt( riskQuestionResponseEvent.getSelectedAnswerID() );
						}
						catch( NumberFormatException nfe )
						{
							weightedResponseID = 0;
						}
					}

					/* Some questions are not answered and have a 0 set
					 * as the weight ID. This means the question was not
					 * answered so no response will be stored
					 */
					if( weightedResponseID > 0 )
					{
						// Create a single RiskQuestionAnswerEvent
						// Single Answer Event
						RiskQuestionAnswerEvent riskQuestionAnswerEvent = new RiskQuestionAnswerEvent(); 
						riskQuestionAnswerEvent.setWeightedResponseID( weightedResponseID );

						riskQuestionAnswerEvent.setUiControlType( riskQuestionResponseEvent.getUiControlType() );

						riskQuestionAnswerEvent.setQuestionNumber( riskQuestionResponseEvent.getQuestionNbr() );
						riskQuestionAnswerEvent.setQuestionText( riskQuestionResponseEvent.getQuestionText() );

						// Set AnswerText on riskQuestionAnswerEvent
						for(int k = 0; k < riskWeightedResponseEvents.length; k++)
						{
							int possibleSelectedWeightResponseid = riskWeightedResponseEvents[k].getWeightedResponseID();
							int possibleSelectedWeightResponse = riskWeightedResponseEvents[k].getWeight();
							String possibleSelectedWeightResponseText = riskWeightedResponseEvents[k].getAnswerText();

							if( weightedResponseID == possibleSelectedWeightResponseid )
							{
								riskQuestionAnswerEvent.setWeight( possibleSelectedWeightResponse );
								riskQuestionAnswerEvent.setAnswerText( possibleSelectedWeightResponseText );
								break;
							}
						}

						weightResponses.add( riskQuestionAnswerEvent );
					}
				} // if control type is radio or drop down
			}
		} // while iterator
		
		return weightResponses;
	}

}